<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOs cp 去掉覆盖提醒]]></title>
    <url>%2F2019%2F04%2F19%2FCentos-cp-%E5%8E%BB%E6%8E%89%E8%A6%86%E7%9B%96%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[CentOS中cp -f 复制强制覆盖的命令总是无效？ 原因是Linux下默认cp命令是有别名的(alias cp=’cp -i’)，无法在复制时强制覆盖，即使你用 -f 参数也无法强制覆盖文件 1.取消cp的alias(暂时生效) # unalias cp # cp -rf /blog 2.加反斜杠 \cp 执行cp命令时不走alias # \cp -rf /blog 3.interesting的方法 # yes|cp -rf /blog 这波操作，大家学会了没？测试1测试2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典游戏贪吃蛇Snake]]></title>
    <url>%2F2018%2F08%2F24%2F%E7%BB%8F%E5%85%B8%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%90%83%E8%9B%87Snake%2F</url>
    <content type="text"><![CDATA[H5小游戏100例: 贪吃蛇贪吃蛇的经典玩法有两种： 积分闯关 一吃到底 第一种是笔者小时候在掌上游戏机最先体验到的（不小心暴露了年龄），具体玩法是蛇吃完一定数量的食物后就通关，通关后速度会加快；第二种是诺基亚在1997年在其自家手机上安装的游戏，它的玩法是吃到没食物为止。笔者要实现的就是第二种玩法。 MVC设计模式基于贪吃蛇的经典，笔者在实现它时也使用一种经典的设计模型：MVC（即：Model - View - Control）。游戏的各种状态与数据结构由 Model 来管理；View 用于显示 Model 的变化；用户与游戏的交互由 Control 完成（Control 提供各种游戏API接口）。 Model 是游戏的核心也是本文的主要内容；View 会涉及到部分性能问题；Control 负责业务逻辑。 这样设计的好处是： Model完全独立，View 是 Model 的状态机，Model 与 View 都由 Control 来驱动。 Model看一张贪吃蛇的经典图片。 贪吃蛇有四个关键的参与对象： 蛇（snake） 食物（food） 墙（bounds） 舞台（zone） 舞台是一个 m * n 的矩阵（二维数组），矩阵的索引边界是舞台的墙，矩阵上的成员用于标记食物和蛇的位置。 空舞台如下：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 食物（F）和蛇（S）出现在舞台上：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,F,0,0,0,0,0,0,0], [0,0,0,S,S,S,S,0,0,0], [0,0,0,0,0,0,S,0,0,0], [0,0,0,0,S,S,S,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 由于操作二维数组不如一维数组方便，所以笔者使用的是一维数组， 如下：123456789101112[ 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,F,0,0,0,0,0,0,0, 0,0,0,S,S,S,S,0,0,0, 0,0,0,0,0,0,S,0,0,0, 0,0,0,0,S,S,S,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,] 舞台矩阵上蛇与食物只是舞台对二者的映射，它们彼此都有独立的数据结构： 蛇是一串坐标索引链表； 食物是一个指向舞台坐标的索引值。 蛇的活动蛇的活动有三种，如下： 移动（move） 吃食（eat） 碰撞（collision） 移动蛇在移动时，内部发生了什么变化？ 蛇链表在一次移动过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点。用一个数组来代表蛇链表，那么蛇的移动就是以下的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next); &#125; 数组作为蛇链表合适吗？这是笔者最开始思考的问题，毕竟数组的 unshift &amp; pop 可以无缝表示蛇的移动。不过，方便不代表性能好，unshift 向数组插入元素的时间复杂度是 O(n)， pop 剔除数组尾元素的时间复杂度是 O(1)。 蛇的移动是一个高频率的动作，如果一次动作的算法复杂度为 O(n) 并且蛇的长度比较大，那么游戏的性能会有问题。笔者想实现的贪吃蛇理论上讲是一条长蛇，所以笔者在本文章的回复是 —— 数组不适合作为蛇链表。 蛇链表必须是真正的链表结构。链表删除或插入一个节点的时间复杂度为O(1)，用链表作为蛇链表的数据结构能提高游戏的性能。javascript 没有现成的链表结构，笔者写了一个叫 Chain 的链表类，Chain 提供了 unshfit &amp; pop。以下伪代码是创建一条蛇链表： 1let snake = new Chain(); 由于篇幅问题这里就不介绍 Chain 是如何实现的，有兴趣的同学可以移步到: https://github.com/leeenx/es6-utils#chain 吃食 &amp; 碰撞「吃食」与「碰撞」区别在于吃食撞上了「食物」，碰撞撞上了「墙」。笔者认为「吃食」与「碰撞」属于蛇一次「移动」的三个可能结果的两个分支。蛇移动的三个可能结果是：「前进」、「吃食」和「碰撞」。 回头看一下蛇移动的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next); &#125; 代码中的 next 表示蛇头即将进入的格子的索引值，只有当这个格子是0时蛇才能「前进」，当这个格子是 S 表示「碰撞」自己，当这个格子是 F表示吃食。 好像少了撞墙？笔者在设计过程中，并没有把墙设计在舞台的矩阵中，而是通过索引出界的方式来表示撞墙。简单地说就是 next === -1 时表示出界和撞墙。 以下伪代码表示蛇的整上活动过程：123456789101112// B 表示撞墙let cell = -1 === next ? B : zone[next]; switch(cell) &#123; // 吃食 case F: eat(); break; // 撞到自己 case S: collision(S); break; // 撞墙 case B: collision(B): break; // 前进 default: move; &#125; 随机投食随机投食是指随机挑选舞台的一个索引值用于映射食物的位置。这似乎很简单，可以直接这样写：12// 伪代码food = Math.random(zone.length) &gt;&gt; 0; 如果考虑到投食的前提 —— 不与蛇身重叠，你会发现上面的随机代码并不能保证投食位置不与蛇身重叠。由于这个算法的安全性带有赌博性质，且把它称作「赌博算法」。为了保证投食的安全性，笔者把算法扩展了一下：1234567// 伪代码function feed() &#123; let index = Math.random(zone.length) &gt;&gt; 0; // 当前位置是否被占用 return zone[index] === S ? feed() : index; &#125;food = feed(); 上面的代码虽然在理论上可以保证投食的绝对安全，不过笔者把这个算法称作「不要命的赌徒算法」，因为上面的算法有致命的BUG —— 超长递归 or 死循环。 为了解决上面的致命问题，笔者设计了下面的算法来做随机投食：1234567891011121314151617181920// 伪代码function feed() &#123; // 未被占用的空格数 let len = zone.length - snake.length; // 无法投食 if(len === 0) return ; // zone的索引 let index = 0, // 空格计数器 count = 0, // 第 rnd 个空格子是最终要投食的位置 rnd = Math.random() * count &gt;&gt; 0 + 1; // 累计空格数 while(count !== rnd) &#123; // 当前格子为空，count总数增一 zone[index++] === 0 &amp;&amp; ++count; &#125; return index - 1; &#125;food = feed(); 这个算法的平均复杂度为 O(n/2)。由于投食是一个低频操作，所以 O(n/2)的复杂度并不会带来任何性能问题。不过，笔者觉得这个算法的复杂度还是有点高了。回头看一下最开始的「赌博算法」，虽然「赌博算法」很不靠谱，但是它有一个优势 —— 时间复杂度为 O(1)。 「赌博算法」的靠谱概率 = (zone.length - snake.length) / zone.length。snake.length 是一个动态值，它的变化范围是：0 ~ zone.length。推导出「赌博算法」的平均靠谱概率是： 「赌博算法」平均靠谱概率 = 50% 看来「赌博算法」还是可以利用一下的。于是笔者重新设计了一个算法：12345678910// 伪代码function bet() &#123; let rnd = Math.random() * zone.length &gt;&gt; 0; return zone[rnd] === 0 ? rnd : -1; &#125;function feed() &#123; ...&#125;food = bet(); if(food === -1) food = feed(); 新算法的平均复杂度可以有效地降低到 O(n/4)，人生有时候需要点运气 : )。 View在 View 可以根据喜好选择一款游戏渲染引擎，笔者在 View 层选择了 PIXI 作为游戏游戏渲染引擎。 View 的任务主要有两个： 绘制游戏的界面； 渲染 Model 里的各种数据结构 也就是说 View 是使用渲染引擎还原设计稿的过程。本文的目的是介绍「贪吃蛇」的实现思路，如何使用一个渲染引擎不是本文讨论的范畴，笔者想介绍的是：「如何提高渲染的效率」。 在 View 中显示 Model 的蛇可以简单地如以下伪代码：12345678910// 清空 View 上的蛇view.snake.clean(); model.snake.forEach( (node) =&gt; &#123; // 创建 View 上的蛇节点 let viewNode = createViewNode(node); // 并合一条新蛇 view.snake.push(viewNode); &#125;); 上面代码的时间复杂度是 O(n)。上面介绍过蛇的移动是一个高频的活动，我们要尽量避免高频率地运行 O(n) 的代码。来分析蛇的三种活动：「移动」，「吃食」，「碰撞」。 首先，Model 发生了「碰撞」，View 应该是直接暂停渲染 Model 里的状态，游戏处在死亡状态，接下来的事由 Control 处理。 Model 中的蛇（链表）在一次「移动」过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点；蛇（链表）在一次「吃食」过程中只做一件事：向表头插入一个新节点。 如果在 View 中对 Model 的蛇链表做差异化检查，View 只增量更新差异部分的话，算法的时间复杂度即可降低至 O(1) ~ O(2) 。以下是优化后的伪代码： 12345678910111213141516171819202122232425let snakeA = model.snake, snakeB = view.snake; // 增量更新尾部while(snakeB.length &lt;= snakeA.length) &#123; headA = snakeA.next(); // 头节点匹配 if(headA.data === headB.data) break; // 不匹配 else &#123; // 向snakeB插入头节点 if(snakeA.HEAD === headA.index) &#123; snakeB.unshift(headA.data); &#125; // 向snakeB插入第二个节点 else snakeB.insertAfter(0, headA.data); &#125;&#125;// 增量更新头部 let tailA = snakeA.last(), tailB; while(snakeB.length !== 0) &#123; tailB = snakeB.last(); // 尾节点匹配 if(tailA.data === tailB.data) break; // 不匹配 else snakeB.pop(); &#125; ControlControl 主要做 3 件事： 游戏与用户的互动 驱动 Model 同步 View 与 Model 「游戏与用户的互动」是指向外提供游戏过程需要使用到的 APIs 与 各类事件。笔者规划的 APIs 如下： name type detail init method 初始化游戏 start method 开始游戏 restart method 重新开始游戏 pause method 暂停 resume method 恢复 turn method 控制蛇的转向。如：turn(“left”) destroy method 销毁游戏 speed property 蛇的移动速度 事件如下： name detail countdown 倒时计 eat 吃到食物 before-eat 吃到食物前触发 gameover 游戏结束 事件统一挂载在游戏实例下的 event 对象下。1snake.event.on("countdown", (time) =&gt; console.log("剩余时间：", time)); 「驱动 Model 」只做一件事 —— 将 Model 的蛇的方向更新为用户指定的方向。「同步 View 与 Model 」也比较简单，检查 Model 是否有更新，如果有更新通知 View 更新游戏界面。 结语本文转载自：https://github.com/leeenx/snake 下面是本文介绍的贪吃蛇的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/snake 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo和github搭建个人博客小站全攻略]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B0%8F%E7%AB%99%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[如何用hexo与github搭建一个属于你自己的个人博客站点呢？ 一.了解hexo与github1.hexo是什么？ hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.github是什么？ 1.gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 2.一个博客网站建立好之后，想让所有人去访问，必须要有服务器和域名，仅仅在你的电脑上运行是远远不够的，而服务器和域名需要购买和备案(国内)，这其中要不但要花钱还要花时间去备案，所以对于一个博客站点来说，这些代价无疑是巨大的。 3.github是免费的，可以把你写好的博客网站托管在github上边，通过Github Pages实现个人网站。 4.Github Pages是Github免费提供给开发者的一款托管个人网站的产品，它可以免费提供一个域名username.github.io去访问你的博客网站，而username就是你在注册github的用户名，至于更详细的内容请接着往下看。 5.我的小站：pengqiangsheng.github.io 3.如何安装？ 安装hexo前，首先检查你的电脑是否安装下列应用程序：1.Node.js2.Git安装Node.js和Git之后我们可以运行使用Win+R打开运行窗口，然后输入cmd进入命令提示符：$ node --version如果看到上述内容说明Node.js已经安装成功了$ git --version如果看到上述内容说明git已经安装成功了如果出现提示“不是内部或外部命令…”请看第5点的注意事项 4.安装hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo$ npm install -g hexo-cli等待安装完成后$ hexo --version看到这些信息说明hexo安装完成 5.注意事项 1.如果出现提示“node不是内部或外部命令，也不是可运行的程序或批处理文件”此类的提示可能有两个原因 环境变量 百度“xxx环境变量如何添加” 管理员权限的命令提示符 如果环境变量添加完成后还是不行，请运行管理员权限的命令提示符 2.关于想Node.js与Git的更深入的了解的小伙伴可以自行百度 二.Hexo建站1.在你电脑的一个你熟悉的位置新建一个文件夹hexo 2.在命令提示符中进入这个文件夹后执行hexo init $ hexo init耐心等待一小会时间如果看到以上信息说明hexo init成功了，接着打开刚刚创建的文件夹，可以看到这样的目录结构：hexo|–node_modules|–scaffolds|–source(存放文章)|–themes(主题)|—-.gitignore|—-config.yml(站点配置文件)|—-db.json|—-package.json|—-package-lock.json这里对hexo目录就不进行太多的讲解需要详细了解的朋友，请转到: 文档|hexo 3.部署你的博客网站到本地进行预览 按照顺序三步走 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo clean 生成静态页面至public目录$ hexo generate 开启预览访问端口（默认端口4000，’ctrl + c’关闭server)$ hexo server 4.打开浏览器 访问http://localhost:4000/访问后，应该可以看到如下页面，说明你的博客小站搭建成功了！这个页面的主题是hexo官方自带主题landscape 5.主题配置 这里呢，我推荐使用Next主题 进入hexo根目录$ cd your-hexo-site 使用git clone下载Next主题到thems文件夹下$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成后可以在hexo/themes文件夹下看到：打开hexo根目录下的config.yml文件找到字段theme: landscape把landscape换成next，然后保存接着按照部署到本地的方法执行这三步$ hexo clean$ hexo generate$ hexo server然后打开你的浏览器访问http://localhost:4000/你会神奇的发现主题已经换成next的简约风格 6.更多关于Next主题的内容 请访问：Next使用文档 三.在Github上托管hexo博客1.注册github账号 访问github输入账号，邮箱，密码进行注册 2.新建一个项目 3.配置项目信息 注意项目名字格式必须是:username.github.iousername就是你注册时的用户名 4.创建好之后来到项目页面 复制一下https的项目地址 5.上传本地hexo博客项目到github上 有两种方式，一种是https传输，另一种是ssh秘钥传输 https传输这种方式流程较为简单，但每次上传代码都需要输入github账号和密码 ssh秘钥传输这种方式配置流程比较复杂，但配置完成后上传代码更为便捷 5.1 https方式上传代码 打开hexo根目录下的config.yml文件找到deploy:字段，修改如下：1234deploy: type: git repo: https://github.com/Johnlly/johnlly.github.io.git branch: master repo后填的参数就是你的项目地址，然后保存打开命令提示符进入hexo目录$ hexo deploy既可把本地代码上传至github如果出现ERROR Deployer not found: git请先执行npm install --save hexo-deployer-git然后再$ hexo deploy执行过程中会让你输入github的账号和密码账号密码验证成功后提示以下信息说明上传代码成功 5.2 ssh秘钥传输5.2.1 检查本机现有的ssh秘钥 输入以下两条命令查看你是否有名为id_rsa和id_dsa.pub的2个文件如果没有转到步骤2，否则请跳到第3步$ cd ~/.ssh$ ls 5.2.2 创建一个新的ssh秘钥 $ ssh-keygen -t rsa -C &quot;注册Github用的邮箱&quot;输入命令后遇到需要你输入的时候，请按回车键，一共三次回车。现在你已经生成了一个ssh秘钥了 5.2.3 将你的SSH key添加到GitHub(或者别的托管平台) $ clip &lt; ~/.ssh/id_rsa.pub运行这条命令可以将秘钥的内容复制到剪切板然后打开github，添加ssh秘钥 5.2.4 测试ssh秘钥是否成功添加到GitHub $ ssh -T git@github.com注意就是运行此命令执行过程中会有如下提示，选择yes即可Are you sure you want to continue connecting (yes/no)? yes你会看到如下有关成功的标志You’ve successfully authenticated, but GitHub does not provide shell access. 5.2.5 用ssh方式上传代码至GitHub 打开hexo根目录下的config.yml文件找到deploy:字段，修改如下：1234deploy: type: git repo: git@github.com:johnlly/johnlly.github.io.git branch: master 打开命令提示符进入hexo目录执行$ hexo deploy即可上传 5.3 打开你的github项目页面 看到如下信息,你的博客代码已经成功的托管在github上了 5.4 打开浏览器 输入username.github.io，username就是你的github用户名例如我的https://johnlly.github.io/可以访问到页面至此就大功告成了，剩下的就是主题的配置和文章的撰写了 后续更新…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo生成博文插入图片的办法]]></title>
    <url>%2F2018%2F08%2F17%2Fhexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo生成博文插入图片的办法 一.首先进入Hexo1.把主页配置文件_config.yml 里的post_asset_folder这个选项设置为true2.在你的hexo目录下执行命令 $ npm install hexo-asset-image--save这是下载安装一个可以上传本地图片的插件，来自CodeFalling 3.等待安装完成后 再运行$ hexo new &quot;xxx&quot;来生成md博文时可以看到/source/posts文件夹内除了xxx.md文件还有一个同名的文件夹 4.最后在xxx.md博文中想引入图片时 先把图片复制到xxx这个文件夹中然后只需要在xxx.md中按照markdown的格式引入图片![你想输入的替代文字](xxx/图片名.jpg) 二.注意事项1.路径问题 注意： xxx是这个md文件的名字，也是同名文件夹的名字只需要有文件夹名字即可，不需要有什么绝对路径你想引入的图片就只需要放入xxx这个文件夹内就好了，很像引用相对路径 2.打开Chrome控制台查看图片真正的路径 最后检查一下，$ hexo g生成页面后进入public\2018\08\17\index.html文件中查看相关字段可以发现html标签内的语句是&lt;img src=&quot;2018/08/17/xxx/图片名.jpg&quot;&gt;而不是&lt;img src=&quot;xxx/图片名.jpg&gt;这很重要,关乎你的网页是否可以真正加载你想插入的图片]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github更新项目]]></title>
    <url>%2F2018%2F08%2F17%2Fgithub%E6%9B%B4%E6%96%B0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[更新github上的项目 一.克隆代码准备工作：1.git客户端 2.github账户1.在本地建立一个文件夹，在此处点击右键，选择git bash here 进入此文件夹 右键选择git bash 2.把自己的代码clone到本地，或者clone别人的到本地 $ git clone https://github.com/xxx 3.clone完成后查看本地代码 二.更新代码1.新增一个mytest的文件夹，里面有一个my.txt 新建文件夹 $ mkdir mytest 创建my.txt $ touch my.txt 2.使用git status命令查看状态查看当前git仓库状态，发现有新的文件 git status 三.更新代码1.使用git add命令 $ git add * –代表更新全部 2.使用git commit -m “更新说明”,commit只是提交到缓存区域 $ git commit -m &quot;更新说明&quot; 3.如果多人同时开发维护代码，得先git pull,拉取当前分支最新代码 $ git pull 4.最后git push origin master,最后一步才是push到远程master分支上 $git push origin master 5.打开github界面查看到更新状态]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>
