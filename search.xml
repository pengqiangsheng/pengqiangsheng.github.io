<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用树莓派构建一台服务器，永久运行网站]]></title>
    <url>%2F2019%2F05%2F10%2F%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9E%84%E5%BB%BA%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B0%B8%E4%B9%85%E8%BF%90%E8%A1%8C%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一、前言由于本人在这段时候，看到了一个叫做树莓派的东东，初步了解之后觉得很有意思，于是想把整个过程记录下来。 二、树莓派是什么？Raspberry Pi(中文名为树莓派,简写为RPi，(或者RasPi / RPI) 是为学习计算机编程教育而设计)，只有信用卡大小的微型电脑，其系统基于Linux。随着Windows 10 IoT的发布，我们也将可以用上运行Windows的树莓派。自问世以来，受众多计算机发烧友和创客的追捧，曾经一“派”难求。别看其外表“娇小”，内“心”却很强大，视频、音频等功能通通皆有，可谓是麻雀虽小，五脏俱全。 1.用我的话理解用我的话理解就是树莓派就是一台主机，你可以外接显示器，键盘鼠标，u盘等等外设，因为它体积很小，而且又有很多串口和外接的口，可以直接调用很多底层硬件。 2.市面上的型号市面上大多是3代B+型，淘宝一搜树莓派一大堆都是，价钱纯主板（不要任何外设）在230+左右，有点小贵，超过我的预算，所以我继续寻找廉价的，终于让我发现了一款100+的树莓派。 3.树莓派zero w树莓派zero w是一款mini的树莓派，体质只有3b+的1/3。实际到手后，你会发现它真的超级小，超级可爱。以下是我的实物图，你可以看看大小到底有多mini。 你可以看到，最上面是一根普通的黑色签字笔，接下来是一个即插即用型的外接wifi网卡，然后是一个USB读卡器，最底下的就是我们今天的主角zero w。它真的超级小，有木有。真的是完美的诠释了那句“麻雀虽小，五脏俱全”的话。 zero w这款树莓派的主要参数如下： BCM2835处理器，1GHz主频，512MB RAM BCM43438 WiFi / BT芯片 micro-USB电源接口 micro-USB OTG接口 miniHDMI端口 复合视频和重置扩展接口 脆弱的CSI摄像头接口 micro-SD卡座，存放操作系统 40-pin GPIO扩展接口 尺寸：65mm*30mm 你别看它的cpu只有1核，内存只有512MB，就觉得它可能什么都做不了，但是实际上它的性能还是很好的，用于跑一个网站真的是小case。 4.更多树莓派关于更多树莓派型号或者使用教程你可以去树莓派实验室这个网站，上面有丰富的资源。 三、树莓派zero w安装系统1.准备你可能提前需要准备的东西如下: 16GB or 32GB 的SanDisk内存卡（注意是以前那种放在手机上，很小的哦） 一根最普通不过的usb安卓数据线（not type-c） u盘格式化工具（推荐使用 SDFormatter） 系统烧写工具（Win32DiskImager） 树莓派系统（可以去官网下载） 我使用的是Raspbian Stretch Lite这个系统镜像，这个系统是官方制作的，lite是无桌面版的，只有黑漆漆的控制台，优点是体积小，省性能和内存。 名字带有desktop的是有桌面ui的，对不熟悉liunx系统的朋友可能更友好，但是体积很大，占用的性能也会更高。 2.第一步下载系统镜像下载好你需要的系统镜像后，如下图 一开始只有一个zip的压缩包，大小大概360MB左右，你需要把它解压，得到上图的文件夹 然后进入文件夹可以看到一个img的镜像，大小为1.7GB左右 ps：这个官方的Raspbian镜像，如果是其他第三方的镜像，可能下载后的压缩包解压后不是img镜像，这种情况请另行百度解决 3.使用Win32DiskImager往内存卡中写入镜像 把内存卡插入读卡器后，插入电脑。打开Win32DiskImager软件后，选择img镜像，设备选择你的U盘，然后点击写入就可以了，写入完成后会弹出成功的提示框。 ps: 我上图没有选择设备，因为的没插入读卡器，仅仅是示范而已 4.修改boot分区的文件先别急着拔出读卡器，此时，我们电脑可以看到u盘中只有一个名为boot的分区，大小可能只有40MB左右，不要着急，因为window不识别内存卡中liunx系统的其他分区。 4.1新建ssh文件因为我们的zero w有一个mini hdmi的接口，但是我不需要屏幕，所以需要使用ssh连接到zero w中的系统，所以需要在第一次开机就能开启ssh功能。我们进入boot分区内，然后新建一个名为ssh的文件，注意不要后缀名！！！！也不要往里面写任何东西！！ 4.2新建wpa_supplicant.conf文件因为ssh连接是需要ip地址的，所以我们需要将zero w在第一次开机自动连接wifi，使其和我们的电脑处于一个局域网，这样我们才可以通过ssh连接到zero w的系统。同样的在boot分区内，新建一个名为wpa_supplicant.conf的文件，然后往里面写入如下内容后保存： 12345678country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;你的wifi名字&quot;psk=&quot;你的wifi密码&quot;&#125; 5.组装我们的最小主机并连接取出读卡器中的内存卡，然后插入到zero w中，使用一根usb安卓数据线连接电源（5V1A）即可。等待几分钟，期间我们的zero w的指示灯会一直闪烁，很正常，等待指示灯常亮的时候，我们去路由器上，查看一下树莓派的ip地址。 可以看到我们zero w的ip为192.168.0.104，然后使用ssh连接工具（推荐使用putty）连接树莓派，初始账户为pi，密码是raspberry。 连接成功，如上图所示。这样我们的系统就正确无误的安装好了。 ps: 如果是手机开启热点当做一个路由器的话，咱们手机下载一个名叫android terminal的app，然后输入ip neigh指令，就可以查到连接到手机的设备的ip信息了。 6.优化咱们树莓派的系统6.1修改源因为国外的源，咱们在国内的连接过去网速很慢，所以我们需要修改为国内的源，我修改的是中科大的源。 6.1.1修改sources.list文件123sudo nano /etc/apt/sources.list --注释其他内容，添加以下:deb http://mirrors.ustc.edu.cn/raspbian/raspbian/raspbian stretch main contrib non-free rpi 6.1.2修改raspi.list文件123sudo nano /etc/apt/sources.list.d/raspi.list--注释其他内容，添加以下:deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian stretch main ui 6.1.3执行更新12sudo apt-get updatesudo apt-get upgrade 6.2修改时区1sudo dpkg-reconfigure tzdata 找到亚洲Asia，然后选择shanghai就可以了 6.3开机自启ssh第一种： 1sudo raspi-config 进入选择找到interfacing option选择，然后找到ssh，按回车使能enable就可以了 第二种： 在终端命令行中启动SSH服务后，如果系统重启或关机后启动，SSH服务默认是关闭的，依然需要手动启动，为了方便可以设置SSH服务开机自动启动，打开/etc/rc.local文件，在语句exit 0之前加入：/etc/init.d/ssh start 建议都试试，反之我的是可以了。 7.安装nginx12345678#安装sudo apt-get install nginx#启动sudo /etc/init.d/nginx start#重启sudo /etc/init.d/nginx restart#停止sudo /etc/init.d/nginx stop 打开浏览器访问192.168.0.104（你的树莓派ip地址），可以看到nginx的页面，说明安装好了。我这边上传了我的博客，如下图 可以正常的看到页面了，但是这样只能在内网（局域网中）看到，我想让所有人都可以访问怎么办？ 8.内网穿透内网穿透，意思就是将内网（本地）的web应用通过nat穿透到公网上，从而让别人可以访问到。 内网穿透目前主要由ngrok和frp两种，都非常好用，国内ngrok免费的有ittun、sunny和natapp，这三个都是免费的，前面两个可以自定义域名，后面的需要vip版本才可以自定义域名。 我这三种都试过，我发现sunny的arm版本的ngrok客户端在我的树莓派运行不了，ittun的和natpp的ngrok都可以，由于需要自定义域名，我使用的是ittun的ngrok_arm版本的 使用方法这三者官网都有详细说明，大家自行查看。 这是正常运行时的截图，访问http://zerow.ittun.com/时可以看到控制台http请求日志 因为需要ngrok在后台运行，所以我用的是screen会话使其可以在后台运行。但是开启自启，还没有实现，万一断电或者断网了，我必须手动去运行一下ngrok，这是目前没有解决的痛点。 9.更多树莓派不仅仅只是可以用于运行一个网站，还有很多很多的功能等待你的开发，可以多去看看树莓派实验室里面，很多大神都写了很多实用的教程。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国福州鼓山半日游]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%B8%AD%E5%9B%BD%E7%A6%8F%E5%B7%9E%E9%BC%93%E5%B1%B1%E5%8D%8A%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[前言这几天五一小长假，5.1和5.2天气都不太好，今天天气格外的给面子呀，正好赶上福州地铁2号线开通了。 准备1.运动包+水壶+帽子2.拉上几个好基友3.带上你的手机 路线图7:40分从宿舍出发，去学校北门公交车站坐48路公交==&gt;8点5分到上街地铁口==&gt;乘坐2号线==&gt;9点04分出了鼓山地铁口==&gt;9点10分鼓山山脚下==&gt;上山估摸着10点出头一些到了鼓山十八景公园南大门吧，在南大门买了3张门票，成人票10元一人，我们带了学生证5元一张。 门票背面画着十八景的路线图啊，对于路痴可能是一个很痛苦的事情。 景点 名称 序号 1.达摩面壁 2.南极升天 3.仙猿守峡 4.老鹤巢云 5.仙人巨迹 6.福寿泉图 7.蟠桃满坞 8.玉笋成林 9.蚁艇渡湖 10.鱼灯普照 11.狮子戏球 12.金蟾出洞 13.伏虎驮经 14.神龙听法 15.铠甲卸岩 16.慈航架壑 17.八仙岩洞 18.千佛梵宫 本来想去看看南极升天的，没成想走错路了，来到了地图上右边这一小块的地方，那就将就着看吧。第一个看到的应该是八仙岩洞 清风明月 在旁边石凳上，拍了个合照 往前走去，有个瑶池啥子的玩意来着然后在旁边石壁拍了几张 继续往前探去，来到一个路口，听游客说左边的路走不通了，我偏不信还，往左走去，没几步前面断了路，于是返回原路往右达摩洞走去。到了达摩洞，几块巨石巧夺天工，构成了一个不深的洞穴，左边巨石就是达摩面壁的墙壁，洞最里处供奉着几尊菩萨，过于神圣，不敢亵渎，又是乎没有photo过了达摩洞后又去了登高台瞭望整个福州，登高眺远，真有一种会当凌绝顶，一览纵山小的feel，海拔大概500多不到600的样子吧。路上有很多这样的石刻的地图 来到佛窟这边 从佛窟出来又到了一个路口 在路口上面有个鼓山赋啊，那文采，学富五车 最后去瞟了一眼一笔成虎 大概感觉这十八景徒有虚名，都是一些石壁刻字，强行凑了十八个景点出来，但是基于门票如此廉价，我也不好多说什么。看了一眼时间大概是11点10几分吧，然后往南大门出口走出去。又到了鼓山十八景公园这边，去了趟洗手间准备下山。在鼓山站坐地铁到了师大站，12点45分出的师大地铁口，然后去正荣半天妖吃了一顿好的，吃饱喝足已是下午2点。半天下来，步数一共17k多吧，我的老寒腿啊，下山的时候一直抖。。。。 后话福州两大名山，鼓山旗山，都可以一去啊。抓住大学最后的尾巴，好好的浪一波。]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
        <tag>福州，鼓山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深海迷航联机教程]]></title>
    <url>%2F2019%2F05%2F02%2F%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E8%81%94%E6%9C%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[深海迷航联机mod教程声明此联机mod由碧蓝之星提供，使用mod前先关闭所有杀毒软件还有防火墙 使用方法1.首先下载一个蒲公英vpn点击下载安装==&gt;蒲公英 2.注册一个账号然后注册账号==&gt;点击注册 3.登陆然后登陆蒲公英网站==&gt;点击登陆 4.进入控制台来到控制台 5.组网点击智能组网，管理默认网络设置入网方式为允许任何人加入网络后确认即可，记住你的网络ID，例如下图的是513614009 6.打开蒲公英软件然后来到桌面，打开蒲公英软件后登陆点击个人头像那里加入其它网络点击我知道了输入网络ID，加入网络注意只支持3个人组网联机，3个人都必须加入同一个网络ID 7.使用联机mod点击下载安装==&gt;联机mod-1.3复制到游戏根目录，双击安装后即可开启联机了。这样你就可以加入别人的房间了，但是你自己无法开启主机（就是自己做主机，别人来连接） 8.开启主机建房间首先关闭window防火墙，自行百度。找到游戏主目录双击联机服务端.bat后出现如下页面黑色控制台上第一步需要输入端口，我们直接按回车使用默认端口就行。第二步需要你输入游戏目录，我们先在文件中返回上一层目录。然后拖游戏目录进去然后去掉引号再按一次回车就可以开启主机了，注意这个黑色的控制台界面不要关闭！！！！然后叫上你的小伙伴进入你的ip就可以联机，你的ip在蒲公英上有个主机172.xx.xx.xx你复制一下发给好友，注意要处于同一个蒲公英网络下才可以联机，目录蒲公英组网只支持3个人（免费版）上图框框圈起来的是你的ip，把这个发给好友，可以看到现在蒲公英有两个人，一个是我，一个是我的好友。我们两个人处于同一个局域网，所以可以联机。 9.祝你联机愉快，如果有版权问题，请联系我]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>深海迷航，联机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小飞机ss/ssr的部署方法]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%B0%8F%E9%A3%9E%E6%9C%BAss-ssr%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、什么是小飞机呀？ 小飞机就是可以飞出去的东西啦（fq）懂了吧。 二、如何部署1.首先你需要一台云服务器或者一台vps2.开始安装1234567yum update -yyum install unzip zip -yyum install wget -ywget -N –no-check-certificate https://raw.githubusercontent.com/Moexin/Easy-SSR-Bash-Python-The-Final/master/ssr.zipunzip ssr.zipcd SSR*bash install.sh 3.开启服务并设置用户端口123cd /usr/local/SSR*./serve.sh ==&gt; 开启服务./user.sh ==&gt; 设置用户 4.复制添加用户成功后的一段ssr链接我框起来那部分复制一下，然后保存起来 5.客户端连接小飞机1.Android首先在手机里复制一下刚刚那个ssr链接 然后打开shadowsocks R软件后，点击标题那里，下图黄色框框 然后点击右下角的+号，接着点击import from Clipboard 会弹出一个框，点确认ok 然后选中这个节点后会回到主界面，点击右上角的小飞机，即刻飞行！ google页面 Yutobe页面 2.Window双击打开shadowsock-R软件后，在状态栏中找到小飞机图标。然后右键选择从剪贴板导入，然后确定即可 系统代理模式选择PAC 代理规则绕过局域网和大陆 google页面 twitch页面 3.iphone和mac也有各自的客户端后续整理 4.各类客户端下载地址后续整理，如有需要先email我]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssr</tag>
        <tag>ss</tag>
        <tag>小飞机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos部署ngrok内网穿透服务器]]></title>
    <url>%2F2019%2F05%2F02%2FCentos%E9%83%A8%E7%BD%B2ngrok%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、前言 ngrok 是一个反向代理,通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。简单理解就是可以实现内网穿透到公网。 二、准备 1台云服务器或者vps+一个域名 三、开搞1.安装go语言123456789//请下载合适自己的go语言包 我是centos 7 64位 所以选择以下包wget https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gztar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gzvim /etc/profile//添加以下内容：export PATH=$PATH:/usr/local/go/binsource /etc/profile//检测是否安装成功gogo version 2.下载ngrok源码并编译123mkdir /ngrokcd /ngrokgit clone https://github.com/inconshreveable/ngrok.git 3.域名解析 解析一个二级域名作为你的ngrok客户端访问的域名，记录类型为A记录，记录值ngrok，ip为你的服务器ip。 4.给你的域名生成证书在ngrok根目录下执行以下命令生成证书 123456cd /ngrokopenssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=myngork.com" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=myngork.com" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 然后执行覆盖命令 123yes|cp rootCA.pem assets/client/tls/ngrokroot.crtyes|cp device.crt assets/server/tls/snakeoil.crtyes|cp device.key assets/server/tls/snakeoil.key 5.编译服务端ngrokd #编译ngrokd（服务器端）make release-server编译结束后会在ngrok/bin目录下生成一个ngrokd文件，这个文件就是服务器端启动的程序。 6.编译客户端ngrok当服务器端ngrok启动后，在客户端，也就是window下的需要内网穿透场景的地方也需要一个启动程序来启动。我客户端电脑是window64位的，所以命令就是GOOS=windows GOARCH=amd64 make release-client编译成功后会在ngrok/bin/windows_amd64/目录下面有ngrok.exe,把这个exe文件下载到你的客户端电脑中。 #Linux 平台 32 位系统：GOOS=linux GOARCH=386 make release-client #Linux 平台 64 位系统：GOOS=linux GOARCH=amd64 make release-client #Windows 平台 32 位系统：GOOS=windows GOARCH=386 make release-client #Windows 平台 64 位系统：GOOS=windows GOARCH=amd64 make release-client #MAC 平台 32 位系统：GOOS=darwin GOARCH=386 make release-client #MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64 make release-client #ARM 平台：GOOS=linux GOARCH=arm make release-client 7.启动服务端ngrokd/bin/ngrokd -tlsKey=&quot;assets/server/tls/snakeoil.key&quot; -tlsCrt=&quot;assets/server/tls/snakeoil.crt&quot; -domain=&quot;myngrok.com&quot; -httpAddr=&quot;:9000&quot; -httpsAddr=&quot;:9001&quot; -tunnelAddr=&quot;:4443&quot; #参数说明： #-domain 访问ngrok是所设置的服务地址生成证书时那个 #-httpAddr http协议端口 默认为80 #-httpsAddr https协议端口 默认为443 （可配置https证书） #-tunnelAddr 通道端口 默认4443 8.内网穿透实例1.在window里启动一个localhost:4000的hexo博客应用程序。2.从服务器上下载ngrok.exe客户端程序，然后创建一个ngrok文件夹，在里面新建一个ngrok.cfg文件并写入以下内容12server_addr: "ngrok.inner.ink:4443"trust_host_root_certs: false 3.启动内网穿透ngrok.exe打开cmd，然后在ngrok这个目录下输入ngrok -config=ngrok.cfg -subdomain=shmh 4000按回车运行 4.在浏览器中访问shmh.ngrok.inner.ink:9000可以看到我的博客已经被访问了，而且ngrok客服端中也会有GET报文出现。 5.配置deploy.bat文件方便启动12345678910111213141516171819202122232425262728@echo OFFcolor 0aTitle ngrok启动Mode con cols=109 lines=30:STARTECHO.Echo ==========================================================================ECHO.Echo ngrok启动ECHO.Echo 作者: 知与南ECHO.Echo ==========================================================================Echo.echo.echo.:NGROKDEcho 1.请输入自定义域名前缀，如“test”，即分配给你的穿透域名为：“test.ngrok.inner.ink”ECHO.set /p clientid= 请输入：echo.Echo 2.输入需要本地应用端口号，如“4000“ECHO.set /p port= 请输入：echo.ngrok -config=ngrok.cfg -subdomain=%clientid% %port%PAUSEgoto NGROKD 6.这样每次启动程序，只需要双击deploy.bat文件，根据提示输入自定义域名和本地端口按回车运行就可以了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker+gogs+nginx配置Git服务自动部署Web应用]]></title>
    <url>%2F2019%2F04%2F22%2Fdocker-gogs-nginx%E9%85%8D%E7%BD%AEGit%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何部署一个git服务而且又可以自动部署web应用呢？ 1.docker 2.gogs 3.nginx 明白以上三者是什么，就可以开始搞事了！ 一、放通端口，阿里云腾讯云的需要到各自的官网开放1.查看firewall服务状态systemctl status firewalld2.查看firewall的状态firewall-cmd --state3.开启、重启、关闭firewall服务 开启 service firewalld start 重启 service firewalld restart 关闭 service firewalld stop 4.查看防火墙规则firewall-cmd --list-all5.查询、开放、关闭端口 查询端口是否开放 firewall-cmd --query-port=8080/tcp 开放80端口 firewall-cmd --permanent --add-port=80/tcp 移除端口 firewall-cmd --permanent --remove-port=8080/tcp 重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload 参数解释 1、firwall-cmd：是Linux提供的操作firewall的一个工具； 2、–permanent：表示设置为持久； 3、–add-port：标识添加的端口； 二、安装docker1、使用 sudo 或 root 权限登录 Centos。 2、确保 yum 包更新到最新。 $ sudo yum update3、执行 Docker 安装脚本。 $ curl -fsSL https://get.docker.com -o get-docker.sh$ sudo sh get-docker.sh执行这个脚本会添加 docker.repo 源并安装 Docker。 4、启动 Docker 进程。 sudo systemctl start docker5、验证 docker 是否安装成功并在容器中执行一个测试的镜像。 $ sudo docker run hello-worlddocker ps到此，Docker 在 CentOS 系统的安装完成。(这部分教程来自菜鸟教程，更多系统安装请前往菜鸟教程) 三、用小南提供的自动脚本nan-deploy.sh去安装gogs和nginx1、下载nan-deploy.sh$ curl -O http://aboutme.ink/share/nan-deploy.sh2、给脚本赋予权限$ chmod +x nan-deploy.sh3、运行脚本$ ./nan-deploy.sh /home/docker/gogs/ 10080 10022 80参数解释 /home/docker/gogs/ 是参数一，代表了gogs和nginx安装的路径 10080 是参数二，表示gogs应用访问端口，ip:10080去访问gogs首页 10022 是参数三，表示gogs对外暴露的ssh端口，用于配置秘钥后下载和上传git代码 80 是参数四，表示nginx的端口，ip直接可以访问nginx首页（80默认隐藏） 以上四个参数自己调整也可以，新手建议默认按照我的配置就可以了以下是完整运行截图4、打开浏览器访问ip:10080和ip:80如果出现这些页面说明成功了！5、配置gogs，打开页面ip:10080数据库选SQLite3，域名写自己的服务器ip，ssh端口填参数三10022，勾选内置服务器，http端口填写参数二10080，应用url填写ip:10080，然后点立即安装点击立即安装，稍等一会会跳转登陆页面，如下6、然后注册一个账号并且登陆会成为管理员（第一个账号）7、新建一个仓库，并且克隆到本地8、点击仓库设置配置git钩子或者web钩子以上配置只需要修改UserName、repo和repoHttpUrl就行，然后点更新钩子设置9、克隆你的仓库到本地并且添加一个index.txt文件并写入内容10、更新你的本地仓库后，推送到远程仓库如果会显示上图的信息，说明你的钩子设置成功，并且代码已经推送到了nginx服务器上11、打开你的浏览器测试一下可以看到，已经可以访问了12、再次更新你的本地仓库13、推送到远程仓库14、再次打开浏览器访问 小南有话说1.其实我利用的原理就是git本身有钩子的一个功能特点，结合docker下的gogs和nginx开发了一套容易理解又非常高效的web应用自动部署平台2.gogs还支持webhooks的web钩子进行代码的部署，这边我就没有多做讲解了，如果你学会了git钩子部署，那么web钩子部署也不是难事]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用nginx配置反向代理实现二级域名配置到公网ip的不同端口的应用]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%94%A8nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%88%B0%E5%85%AC%E7%BD%91ip%E7%9A%84%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何用nginx配置二级域名解析到ip的不同端口呢总所周知，ip:80这种方式的web应用可以直接用ip去访问，原因是输入ip的时候，浏览器会自动的默认认为是ip:80这样的形式去访问。利用这一点我们可以用域名解析到ip上进行只需要输入www.domain.com去访问web页面。各大网站也是如此。 如果是ip:80以外的端口怎么办？一台服务器不可能说只部署一个web应用吧，其他的都要通过ip+端口或者域名+端口去访问多麻烦啊，而且样子也不好看呀。这个时候，救世主nginx大爷就出现了，他说我有很多的NB功能啊，例如反向代理啊！ 前提你需要有一个域名和一台服务器（国内需备案）然后去解析域名，添加两个A记录如下图 Nginx方向代理我们要如何使用这个技能呢？ 1.首先找到你服务器中nginx的配置文件所在的文件夹 一般都是/usr/local/nginx/conf/这个文件夹下有个nginx.conf或者default.conf反正.conf的文件都看一看 命令是cat nginx.conf 2.然后打开nginx.conf看一眼里面的配置 主要是找到一句话叫做include xxxx/*.conf,如果没有你自己加一句吧 3.然后进入这个xxxx文件夹下新建一个.conf，我这里是gogs.conf 然后编辑gogs.conf的内容为下图，然后保存 4.记得重启nginx，如果没报错的话，你配置应该成功了 然后打开浏览器输入git.aboutme.ink试试成功咯！然后我再来一个cloud.aboutme.ink试试,打开浏览器访问 cloud.aboutme.ink也可以访问了 gogs.conf的代码如下12345678910111213server&#123; listen 80; server_name git.aboutme.ink; location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:10080; &#125; access_log /home/wwwlogs/git.aboutme.ink.log;&#125; 后续大家可以按照我的方法试试看，不行可以留言反馈咯，我会及时解决的。至于这两个应用怎么构建的，后续出教程啊！]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于php执行shell命令的一些体会]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%85%B3%E4%BA%8Ephp%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[关于php执行shell命令不得不提的一些东西前言这几天刚新买了一台阿里云香港的轻量应用服务器价钱还不错，24CNY一月，30Mbs带宽，1024G流量每月。这是我的推荐码的入口阿里云服务器入口咳咳。。。拉回正题，我就开始配了一个lnmp，然后搭了一个docker下的gogs，然后搞了一个webhooks钩子。之前我那台华东2的服务器配的是lamp+docker+gogs，可以自动部署代码上线。所以按照之前的步骤，我一步一步的走啊走啊，然后神奇的发现我的php执行不了shell脚本。然后我各种度娘，google之类，发现说是php.ini里面有个字段叫做disable_funtions把php可以执行的shell函数都禁掉了，只要删掉想要的函数，就可以执行了。之后我打开我的php.ini，然后找啊找，仍是没找到，然后我把这个php.ini整个内容复制到我的win10的word里面，查找这个字段，还是找不到。然后又去百度，然后搜啊搜，找啊找。搞了5、6个小时吧。我都要崩溃了。后来把，我去群里问了个大神，大神一顿操作噼里啪啦，然后说让我把ip给他，他登入我服务器帮我找原因，3秒钟后，大神在php.ini的305行找到了这个字段。顿时，我无语了，我找了这么久都没找到。哎。。懵逼的一天。然后我把shell_exec()从监狱里释放出来，然后在我的领地上，使用这个魔法，成功了，可以执行脚本了。然后就是要给www提升一下权限，让它可以代我去执行各种骚操作具体整个自动部署的教程链接在这里–&gt;自动部署 骚啊骚 搞了我一天]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
        <tag>php</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOs cp 去掉覆盖提醒]]></title>
    <url>%2F2019%2F04%2F19%2FCentos-cp-%E5%8E%BB%E6%8E%89%E8%A6%86%E7%9B%96%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[CentOS中cp -f 复制强制覆盖的命令总是无效？ 原因是Linux下默认cp命令是有别名的(alias cp=’cp -i’)，无法在复制时强制覆盖，即使你用 -f 参数也无法强制覆盖文件 1.取消cp的alias(暂时生效) # unalias cp # cp -rf /blog 2.加反斜杠 \cp 执行cp命令时不走alias # \cp -rf /blog 3.interesting的方法 # yes|cp -rf /blog 这波操作，大家学会了没？学会的扣1，O(∩_∩)O哈哈~]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典游戏贪吃蛇Snake]]></title>
    <url>%2F2018%2F08%2F24%2F%E7%BB%8F%E5%85%B8%E6%B8%B8%E6%88%8F%E8%B4%AA%E5%90%83%E8%9B%87Snake%2F</url>
    <content type="text"><![CDATA[H5小游戏100例: 贪吃蛇贪吃蛇的经典玩法有两种： 积分闯关 一吃到底 第一种是笔者小时候在掌上游戏机最先体验到的（不小心暴露了年龄），具体玩法是蛇吃完一定数量的食物后就通关，通关后速度会加快；第二种是诺基亚在1997年在其自家手机上安装的游戏，它的玩法是吃到没食物为止。笔者要实现的就是第二种玩法。 MVC设计模式基于贪吃蛇的经典，笔者在实现它时也使用一种经典的设计模型：MVC（即：Model - View - Control）。游戏的各种状态与数据结构由 Model 来管理；View 用于显示 Model 的变化；用户与游戏的交互由 Control 完成（Control 提供各种游戏API接口）。 Model 是游戏的核心也是本文的主要内容；View 会涉及到部分性能问题；Control 负责业务逻辑。 这样设计的好处是： Model完全独立，View 是 Model 的状态机，Model 与 View 都由 Control 来驱动。 Model看一张贪吃蛇的经典图片。 贪吃蛇有四个关键的参与对象： 蛇（snake） 食物（food） 墙（bounds） 舞台（zone） 舞台是一个 m * n 的矩阵（二维数组），矩阵的索引边界是舞台的墙，矩阵上的成员用于标记食物和蛇的位置。 空舞台如下：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 食物（F）和蛇（S）出现在舞台上：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,F,0,0,0,0,0,0,0], [0,0,0,S,S,S,S,0,0,0], [0,0,0,0,0,0,S,0,0,0], [0,0,0,0,S,S,S,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 由于操作二维数组不如一维数组方便，所以笔者使用的是一维数组， 如下：123456789101112[ 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,F,0,0,0,0,0,0,0, 0,0,0,S,S,S,S,0,0,0, 0,0,0,0,0,0,S,0,0,0, 0,0,0,0,S,S,S,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,] 舞台矩阵上蛇与食物只是舞台对二者的映射，它们彼此都有独立的数据结构： 蛇是一串坐标索引链表； 食物是一个指向舞台坐标的索引值。 蛇的活动蛇的活动有三种，如下： 移动（move） 吃食（eat） 碰撞（collision） 移动蛇在移动时，内部发生了什么变化？ 蛇链表在一次移动过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点。用一个数组来代表蛇链表，那么蛇的移动就是以下的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next); &#125; 数组作为蛇链表合适吗？这是笔者最开始思考的问题，毕竟数组的 unshift &amp; pop 可以无缝表示蛇的移动。不过，方便不代表性能好，unshift 向数组插入元素的时间复杂度是 O(n)， pop 剔除数组尾元素的时间复杂度是 O(1)。 蛇的移动是一个高频率的动作，如果一次动作的算法复杂度为 O(n) 并且蛇的长度比较大，那么游戏的性能会有问题。笔者想实现的贪吃蛇理论上讲是一条长蛇，所以笔者在本文章的回复是 —— 数组不适合作为蛇链表。 蛇链表必须是真正的链表结构。链表删除或插入一个节点的时间复杂度为O(1)，用链表作为蛇链表的数据结构能提高游戏的性能。javascript 没有现成的链表结构，笔者写了一个叫 Chain 的链表类，Chain 提供了 unshfit &amp; pop。以下伪代码是创建一条蛇链表： 1let snake = new Chain(); 由于篇幅问题这里就不介绍 Chain 是如何实现的，有兴趣的同学可以移步到: https://github.com/leeenx/es6-utils#chain 吃食 &amp; 碰撞「吃食」与「碰撞」区别在于吃食撞上了「食物」，碰撞撞上了「墙」。笔者认为「吃食」与「碰撞」属于蛇一次「移动」的三个可能结果的两个分支。蛇移动的三个可能结果是：「前进」、「吃食」和「碰撞」。 回头看一下蛇移动的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next); &#125; 代码中的 next 表示蛇头即将进入的格子的索引值，只有当这个格子是0时蛇才能「前进」，当这个格子是 S 表示「碰撞」自己，当这个格子是 F表示吃食。 好像少了撞墙？笔者在设计过程中，并没有把墙设计在舞台的矩阵中，而是通过索引出界的方式来表示撞墙。简单地说就是 next === -1 时表示出界和撞墙。 以下伪代码表示蛇的整上活动过程：123456789101112// B 表示撞墙let cell = -1 === next ? B : zone[next]; switch(cell) &#123; // 吃食 case F: eat(); break; // 撞到自己 case S: collision(S); break; // 撞墙 case B: collision(B): break; // 前进 default: move; &#125; 随机投食随机投食是指随机挑选舞台的一个索引值用于映射食物的位置。这似乎很简单，可以直接这样写：12// 伪代码food = Math.random(zone.length) &gt;&gt; 0; 如果考虑到投食的前提 —— 不与蛇身重叠，你会发现上面的随机代码并不能保证投食位置不与蛇身重叠。由于这个算法的安全性带有赌博性质，且把它称作「赌博算法」。为了保证投食的安全性，笔者把算法扩展了一下：1234567// 伪代码function feed() &#123; let index = Math.random(zone.length) &gt;&gt; 0; // 当前位置是否被占用 return zone[index] === S ? feed() : index; &#125;food = feed(); 上面的代码虽然在理论上可以保证投食的绝对安全，不过笔者把这个算法称作「不要命的赌徒算法」，因为上面的算法有致命的BUG —— 超长递归 or 死循环。 为了解决上面的致命问题，笔者设计了下面的算法来做随机投食：1234567891011121314151617181920// 伪代码function feed() &#123; // 未被占用的空格数 let len = zone.length - snake.length; // 无法投食 if(len === 0) return ; // zone的索引 let index = 0, // 空格计数器 count = 0, // 第 rnd 个空格子是最终要投食的位置 rnd = Math.random() * count &gt;&gt; 0 + 1; // 累计空格数 while(count !== rnd) &#123; // 当前格子为空，count总数增一 zone[index++] === 0 &amp;&amp; ++count; &#125; return index - 1; &#125;food = feed(); 这个算法的平均复杂度为 O(n/2)。由于投食是一个低频操作，所以 O(n/2)的复杂度并不会带来任何性能问题。不过，笔者觉得这个算法的复杂度还是有点高了。回头看一下最开始的「赌博算法」，虽然「赌博算法」很不靠谱，但是它有一个优势 —— 时间复杂度为 O(1)。 「赌博算法」的靠谱概率 = (zone.length - snake.length) / zone.length。snake.length 是一个动态值，它的变化范围是：0 ~ zone.length。推导出「赌博算法」的平均靠谱概率是： 「赌博算法」平均靠谱概率 = 50% 看来「赌博算法」还是可以利用一下的。于是笔者重新设计了一个算法：12345678910// 伪代码function bet() &#123; let rnd = Math.random() * zone.length &gt;&gt; 0; return zone[rnd] === 0 ? rnd : -1; &#125;function feed() &#123; ...&#125;food = bet(); if(food === -1) food = feed(); 新算法的平均复杂度可以有效地降低到 O(n/4)，人生有时候需要点运气 : )。 View在 View 可以根据喜好选择一款游戏渲染引擎，笔者在 View 层选择了 PIXI 作为游戏游戏渲染引擎。 View 的任务主要有两个： 绘制游戏的界面； 渲染 Model 里的各种数据结构 也就是说 View 是使用渲染引擎还原设计稿的过程。本文的目的是介绍「贪吃蛇」的实现思路，如何使用一个渲染引擎不是本文讨论的范畴，笔者想介绍的是：「如何提高渲染的效率」。 在 View 中显示 Model 的蛇可以简单地如以下伪代码：12345678910// 清空 View 上的蛇view.snake.clean(); model.snake.forEach( (node) =&gt; &#123; // 创建 View 上的蛇节点 let viewNode = createViewNode(node); // 并合一条新蛇 view.snake.push(viewNode); &#125;); 上面代码的时间复杂度是 O(n)。上面介绍过蛇的移动是一个高频的活动，我们要尽量避免高频率地运行 O(n) 的代码。来分析蛇的三种活动：「移动」，「吃食」，「碰撞」。 首先，Model 发生了「碰撞」，View 应该是直接暂停渲染 Model 里的状态，游戏处在死亡状态，接下来的事由 Control 处理。 Model 中的蛇（链表）在一次「移动」过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点；蛇（链表）在一次「吃食」过程中只做一件事：向表头插入一个新节点。 如果在 View 中对 Model 的蛇链表做差异化检查，View 只增量更新差异部分的话，算法的时间复杂度即可降低至 O(1) ~ O(2) 。以下是优化后的伪代码： 12345678910111213141516171819202122232425let snakeA = model.snake, snakeB = view.snake; // 增量更新尾部while(snakeB.length &lt;= snakeA.length) &#123; headA = snakeA.next(); // 头节点匹配 if(headA.data === headB.data) break; // 不匹配 else &#123; // 向snakeB插入头节点 if(snakeA.HEAD === headA.index) &#123; snakeB.unshift(headA.data); &#125; // 向snakeB插入第二个节点 else snakeB.insertAfter(0, headA.data); &#125;&#125;// 增量更新头部 let tailA = snakeA.last(), tailB; while(snakeB.length !== 0) &#123; tailB = snakeB.last(); // 尾节点匹配 if(tailA.data === tailB.data) break; // 不匹配 else snakeB.pop(); &#125; ControlControl 主要做 3 件事： 游戏与用户的互动 驱动 Model 同步 View 与 Model 「游戏与用户的互动」是指向外提供游戏过程需要使用到的 APIs 与 各类事件。笔者规划的 APIs 如下： name type detail init method 初始化游戏 start method 开始游戏 restart method 重新开始游戏 pause method 暂停 resume method 恢复 turn method 控制蛇的转向。如：turn(“left”) destroy method 销毁游戏 speed property 蛇的移动速度 事件如下： name detail countdown 倒时计 eat 吃到食物 before-eat 吃到食物前触发 gameover 游戏结束 事件统一挂载在游戏实例下的 event 对象下。1snake.event.on("countdown", (time) =&gt; console.log("剩余时间：", time)); 「驱动 Model 」只做一件事 —— 将 Model 的蛇的方向更新为用户指定的方向。「同步 View 与 Model 」也比较简单，检查 Model 是否有更新，如果有更新通知 View 更新游戏界面。 结语本文转载自：https://github.com/leeenx/snake 下面是本文介绍的贪吃蛇的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/snake 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo和github搭建个人博客小站全攻略]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B0%8F%E7%AB%99%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[如何用hexo与github搭建一个属于你自己的个人博客站点呢？ 一.了解hexo与github1.hexo是什么？ hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.github是什么？ 1.gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 2.一个博客网站建立好之后，想让所有人去访问，必须要有服务器和域名，仅仅在你的电脑上运行是远远不够的，而服务器和域名需要购买和备案(国内)，这其中要不但要花钱还要花时间去备案，所以对于一个博客站点来说，这些代价无疑是巨大的。 3.github是免费的，可以把你写好的博客网站托管在github上边，通过Github Pages实现个人网站。 4.Github Pages是Github免费提供给开发者的一款托管个人网站的产品，它可以免费提供一个域名username.github.io去访问你的博客网站，而username就是你在注册github的用户名，至于更详细的内容请接着往下看。 5.我的小站：pengqiangsheng.github.io 3.如何安装？ 安装hexo前，首先检查你的电脑是否安装下列应用程序：1.Node.js2.Git安装Node.js和Git之后我们可以运行使用Win+R打开运行窗口，然后输入cmd进入命令提示符：$ node --version如果看到上述内容说明Node.js已经安装成功了$ git --version如果看到上述内容说明git已经安装成功了如果出现提示“不是内部或外部命令…”请看第5点的注意事项 4.安装hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo$ npm install -g hexo-cli等待安装完成后$ hexo --version看到这些信息说明hexo安装完成 5.注意事项 1.如果出现提示“node不是内部或外部命令，也不是可运行的程序或批处理文件”此类的提示可能有两个原因 环境变量 百度“xxx环境变量如何添加” 管理员权限的命令提示符 如果环境变量添加完成后还是不行，请运行管理员权限的命令提示符 2.关于想Node.js与Git的更深入的了解的小伙伴可以自行百度 二.Hexo建站1.在你电脑的一个你熟悉的位置新建一个文件夹hexo 2.在命令提示符中进入这个文件夹后执行hexo init $ hexo init耐心等待一小会时间如果看到以上信息说明hexo init成功了，接着打开刚刚创建的文件夹，可以看到这样的目录结构：hexo|–node_modules|–scaffolds|–source(存放文章)|–themes(主题)|—-.gitignore|—-config.yml(站点配置文件)|—-db.json|—-package.json|—-package-lock.json这里对hexo目录就不进行太多的讲解需要详细了解的朋友，请转到: 文档|hexo 3.部署你的博客网站到本地进行预览 按照顺序三步走 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo clean 生成静态页面至public目录$ hexo generate 开启预览访问端口（默认端口4000，’ctrl + c’关闭server)$ hexo server 4.打开浏览器 访问http://localhost:4000/访问后，应该可以看到如下页面，说明你的博客小站搭建成功了！这个页面的主题是hexo官方自带主题landscape 5.主题配置 这里呢，我推荐使用Next主题 进入hexo根目录$ cd your-hexo-site 使用git clone下载Next主题到thems文件夹下$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成后可以在hexo/themes文件夹下看到：打开hexo根目录下的config.yml文件找到字段theme: landscape把landscape换成next，然后保存接着按照部署到本地的方法执行这三步$ hexo clean$ hexo generate$ hexo server然后打开你的浏览器访问http://localhost:4000/你会神奇的发现主题已经换成next的简约风格 6.更多关于Next主题的内容 请访问：Next使用文档 三.在Github上托管hexo博客1.注册github账号 访问github输入账号，邮箱，密码进行注册 2.新建一个项目 3.配置项目信息 注意项目名字格式必须是:username.github.iousername就是你注册时的用户名 4.创建好之后来到项目页面 复制一下https的项目地址 5.上传本地hexo博客项目到github上 有两种方式，一种是https传输，另一种是ssh秘钥传输 https传输这种方式流程较为简单，但每次上传代码都需要输入github账号和密码 ssh秘钥传输这种方式配置流程比较复杂，但配置完成后上传代码更为便捷 5.1 https方式上传代码 打开hexo根目录下的config.yml文件找到deploy:字段，修改如下：1234deploy: type: git repo: https://github.com/Johnlly/johnlly.github.io.git branch: master repo后填的参数就是你的项目地址，然后保存打开命令提示符进入hexo目录$ hexo deploy既可把本地代码上传至github如果出现ERROR Deployer not found: git请先执行npm install --save hexo-deployer-git然后再$ hexo deploy执行过程中会让你输入github的账号和密码账号密码验证成功后提示以下信息说明上传代码成功 5.2 ssh秘钥传输5.2.1 检查本机现有的ssh秘钥 输入以下两条命令查看你是否有名为id_rsa和id_dsa.pub的2个文件如果没有转到步骤2，否则请跳到第3步$ cd ~/.ssh$ ls 5.2.2 创建一个新的ssh秘钥 $ ssh-keygen -t rsa -C &quot;注册Github用的邮箱&quot;输入命令后遇到需要你输入的时候，请按回车键，一共三次回车。现在你已经生成了一个ssh秘钥了 5.2.3 将你的SSH key添加到GitHub(或者别的托管平台) $ clip &lt; ~/.ssh/id_rsa.pub运行这条命令可以将秘钥的内容复制到剪切板然后打开github，添加ssh秘钥 5.2.4 测试ssh秘钥是否成功添加到GitHub $ ssh -T git@github.com注意就是运行此命令执行过程中会有如下提示，选择yes即可Are you sure you want to continue connecting (yes/no)? yes你会看到如下有关成功的标志You’ve successfully authenticated, but GitHub does not provide shell access. 5.2.5 用ssh方式上传代码至GitHub 打开hexo根目录下的config.yml文件找到deploy:字段，修改如下：1234deploy: type: git repo: git@github.com:johnlly/johnlly.github.io.git branch: master 打开命令提示符进入hexo目录执行$ hexo deploy即可上传 5.3 打开你的github项目页面 看到如下信息,你的博客代码已经成功的托管在github上了 5.4 打开浏览器 输入username.github.io，username就是你的github用户名例如我的https://johnlly.github.io/可以访问到页面至此就大功告成了，剩下的就是主题的配置和文章的撰写了 后续更新…]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo生成博文插入图片的办法]]></title>
    <url>%2F2018%2F08%2F17%2Fhexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo生成博文插入图片的办法 一.首先进入Hexo1.把主页配置文件_config.yml 里的post_asset_folder这个选项设置为true2.在你的hexo目录下执行命令 $ npm install hexo-asset-image--save这是下载安装一个可以上传本地图片的插件，来自CodeFalling 3.等待安装完成后 再运行$ hexo new &quot;xxx&quot;来生成md博文时可以看到/source/posts文件夹内除了xxx.md文件还有一个同名的文件夹 4.最后在xxx.md博文中想引入图片时 先把图片复制到xxx这个文件夹中然后只需要在xxx.md中按照markdown的格式引入图片![你想输入的替代文字](xxx/图片名.jpg) 二.注意事项1.路径问题 注意： xxx是这个md文件的名字，也是同名文件夹的名字只需要有文件夹名字即可，不需要有什么绝对路径你想引入的图片就只需要放入xxx这个文件夹内就好了，很像引用相对路径 2.打开Chrome控制台查看图片真正的路径 最后检查一下，$ hexo g生成页面后进入public\2018\08\17\index.html文件中查看相关字段可以发现html标签内的语句是&lt;img src=&quot;2018/08/17/xxx/图片名.jpg&quot;&gt;而不是&lt;img src=&quot;xxx/图片名.jpg&gt;这很重要,关乎你的网页是否可以真正加载你想插入的图片]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github更新项目]]></title>
    <url>%2F2018%2F08%2F17%2Fgithub%E6%9B%B4%E6%96%B0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[更新github上的项目 一.克隆代码准备工作：1.git客户端 2.github账户1.在本地建立一个文件夹，在此处点击右键，选择git bash here 进入此文件夹 右键选择git bash 2.把自己的代码clone到本地，或者clone别人的到本地 $ git clone https://github.com/xxx 3.clone完成后查看本地代码 二.更新代码1.新增一个mytest的文件夹，里面有一个my.txt 新建文件夹 $ mkdir mytest 创建my.txt $ touch my.txt 2.使用git status命令查看状态查看当前git仓库状态，发现有新的文件 git status 三.更新代码1.使用git add命令 $ git add * –代表更新全部 2.使用git commit -m “更新说明”,commit只是提交到缓存区域 $ git commit -m &quot;更新说明&quot; 3.如果多人同时开发维护代码，得先git pull,拉取当前分支最新代码 $ git pull 4.最后git push origin master,最后一步才是push到远程master分支上 $git push origin master 5.打开github界面查看到更新状态]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>
